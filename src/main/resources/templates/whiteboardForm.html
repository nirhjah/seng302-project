<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org" lang="en">
<head>
    <link th:href="@{/css/styles.css}" rel="stylesheet"/>
    <link th:href="@{/css/whiteboard.css}" rel="stylesheet">
    <meta http-equiv="Content-Type" context="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Whiteboard</title>
</head>
<body class="view-teams-background">
<div th:insert="~{fragments/navBar.html::navbar(displayTeams=${displayTeams})}"></div>
<div class="whiteboard-form">
    <div class="whiteboard-wrapper">
        <div class="whiteboard-dropdowns">
            <h3 class="whiteboard-title" contenteditable="true">Untitled</h3>

            <div class="dropdown">
                <label for="pitch">Pitch Type</label>
                <select class="select" id="pitch"></select>
            </div>
            <div class="dropdown">
                <label for="formation-dropdown">Formation</label>
                <select name="formation" id="formation-dropdown">
                    <option value="-1">(No Formation)</option>
                    <option th:each="forma : ${teamFormations}"
                            th:value="${forma.formationId}"
                            th:text="${forma.formation}"
                            th:selected="${forma == selectedFormation}"
                            th:data-custom="${forma.custom}"
                            th:data-custom-positions="${forma.customPlayerPositions}">
                    </option>
                </select>
            </div>
            <div class="line">
                <hr>
                <span class="or-text">or</span>
                <hr>
            </div>
            <div class="dropdown">
                <label for="lineup-dropdown" >Line-Up</label>
                <select class="select" id="lineup-dropdown">
                    <option value="-1">(No Lineup)</option>
                    <option th:each="lineup : ${teamLineUps}"
                            th:value="${lineup.lineUpId}"
                            th:text="${lineup.lineUpName}"
                            th:data-custom="${lineup.formation.custom}"
                            th:data-custom-positions="${lineup.formation.customPlayerPositions}"
                    ></option>
                </select>
            </div>

            <div class="player-table">
                <div class="player-header">
                    <h4 class="player-title">Players</h4>
                </div>
                <div class="player-list">
                    <ul class="player-ul">
                        <li class="player-card" th:each="member : ${teamMembers}">
                            <img class="player-image" th:src="@{/user-profile-picture/{id}(id = ${member.userId})}" draggable="false">
                            <span class="player-name" th:text="|${member.firstName} ${member.lastName}|"></span>
                            <input class="player-id" type="hidden" th:value="${member.id}">
                        </li>

                    </ul>
                </div>
            </div>


        </div>
        <div>
            <div class="whiteboard-buttons">
                <button class="select-button active">
                    <span class="tooltip">Select (S)</span>
                    <img class="selected-svg" th:src="@{/image/icons/cursor-selected.svg}"/>
                    <img class="default-svg" th:src="@{/image/icons/cursor.svg}"/>
                </button>
                <button class="draw-button">
                    <span class="tooltip">Free Draw (D)</span>
                    <img class="selected-svg" th:src="@{/image/icons/pencil-selected.svg}"/>
                    <img class="default-svg" th:src="@{/image/icons/pencil.svg}"/>
                </button>
                <div class="customisation-box draw">
                    <div class="style-section">
                        <div class="header">
                            <h5>Style</h5>
                            <!--              <label>Arrow-->
                            <!--                <input class="arrow-checkbox" type="checkbox">-->
                            <!--              </label>-->
                        </div>
                        <div class="content">
                            <button class="draw-style-button-solid active">
                                <img class="selected-svg" th:src="@{/image/icons/solid-line-selected.svg}"/>
                                <img class="default-svg" th:src="@{/image/icons/solid-line.svg}"/>
                            </button>
                            <button class="draw-style-button-dashed">
                                <img class="selected-svg" th:src="@{/image/icons/dashed-line-selected.svg}"/>
                                <img class="default-svg" th:src="@{/image/icons/dashed-line.svg}"/>
                            </button>
                        </div>
                    </div>
                    <div class="colour-section">
                        <div class="header">
                            <h5>Colour</h5>
                        </div>
                        <div class="content">
                            <input class="colour-picker" type="color" value="#ff0000">
                            <div>
                                <h5>#</h5>
                                <input class="colour-value" id="colourValue" value="FF0000">
                            </div>
                        </div>
                    </div>
                    <div class="width-section">
                        <div class="header">
                            <h5>Width</h5>
                        </div>
                        <div class="content">
                            <input id="rangeInput" type="range" min="1" max="50" value="5">
                            <input type="number" max="50" min="1" id="widthValue" value="5">
                        </div>
                    </div>
                </div>
                <button class="erase-button">
                    <span class="tooltip">Erase (E)</span>
                    <img class="selected-svg" th:src="@{/image/icons/eraser-selected.svg}"/>
                    <img class="default-svg" th:src="@{/image/icons/eraser.svg}"/>
                </button>
                <button class="shape-button circle">
                    <span class="tooltip">Shape (X)</span>
                    <span class="circle-img">
              <img class="selected-svg" th:src="@{/image/icons/circle-selected.svg}"/>
              <img class="default-svg" th:src="@{/image/icons/circle.svg}"/>
            </span>
                    <span class="triangle-img">
              <img class="selected-svg" th:src="@{/image/icons/triangle-selected.svg}"/>
              <img class="default-svg" th:src="@{/image/icons/triangle.svg}"/>
            </span>
                    <span class="square-img">
              <img class="selected-svg" th:src="@{/image/icons/square-selected.svg}"/>
              <img class="default-svg" th:src="@{/image/icons/square.svg}"/>
            </span>
                    <span class="ellipse-img">
              <img class="selected-svg" th:src="@{/image/icons/ellipse-selected.svg}"/>
              <img class="default-svg" th:src="@{/image/icons/ellipse.svg}"/>
            </span>
                    <span class="rectangle-img">
              <img class="selected-svg" th:src="@{/image/icons/rectangle-selected.svg}"/>
              <img class="default-svg" th:src="@{/image/icons/rectangle.svg}"/>
            </span>
                    <span class="line-img">
              <img class="selected-svg" th:src="@{/image/icons/straight-line-selected.svg}"/>
              <img class="default-svg" th:src="@{/image/icons/straight-line.svg}"/>
            </span>
                    <span class="arrow-img">
              <img class="selected-svg" th:src="@{/image/icons/arrow-line-selected.svg}"/>
              <img class="default-svg" th:src="@{/image/icons/arrow-line.svg}"/>
            </span>
                </button>
                <div class="customisation-box shape">
                    <div class="style-section">
                        <div class="header">
                            <h5>Style</h5>
                        </div>
                        <div class="content">
                            <button class="draw-style-button-solid active">
                                <img class="selected-svg" th:src="@{/image/icons/solid-line-selected.svg}"/>
                                <img class="default-svg" th:src="@{/image/icons/solid-line.svg}"/>
                            </button>
                            <button class="draw-style-button-dashed">
                                <img class="selected-svg" th:src="@{/image/icons/dashed-line-selected.svg}"/>
                                <img class="default-svg" th:src="@{/image/icons/dashed-line.svg}"/>
                            </button>
                        </div>
                    </div>
                    <div class="shape-section">
                        <div class="header">
                            <h5>Shape</h5>
                        </div>
                        <div class="content">
                            <button class="shape-button-circle active">
                                <img class="selected-svg" th:src="@{/image/icons/circle-selected.svg}"/>
                                <img class="default-svg" th:src="@{/image/icons/circle.svg}"/>
                            </button>
                            <button class="shape-button-triangle">
                                <img class="selected-svg" th:src="@{/image/icons/triangle-selected.svg}"/>
                                <img class="default-svg" th:src="@{/image/icons/triangle.svg}"/>
                            </button>
                            <button class="shape-button-square">
                                <img class="selected-svg" th:src="@{/image/icons/square-selected.svg}"/>
                                <img class="default-svg" th:src="@{/image/icons/square.svg}"/>
                            </button>
                            <button class="shape-button-ellipse">
                                <img class="selected-svg" th:src="@{/image/icons/ellipse-selected.svg}"/>
                                <img class="default-svg" th:src="@{/image/icons/ellipse.svg}"/>
                            </button>
                            <button class="shape-button-rectangle">
                                <img class="selected-svg" th:src="@{/image/icons/rectangle-selected.svg}"/>
                                <img class="default-svg" th:src="@{/image/icons/rectangle.svg}"/>
                            </button>
                            <button class="shape-button-line">
                                <img class="selected-svg" th:src="@{/image/icons/straight-line-selected.svg}"/>
                                <img class="default-svg" th:src="@{/image/icons/straight-line.svg}"/>
                            </button>
                            <button class="shape-button-arrow">
                                <img class="selected-svg" th:src="@{/image/icons/arrow-line-selected.svg}"/>
                                <img class="default-svg" th:src="@{/image/icons/arrow-line.svg}"/>
                            </button>
                        </div>
                    </div>
                    <div class="fill-section">
                        <div class="header">
                            <h5>Fill</h5>
                        </div>
                        <div class="content">
                            <input class="colour-picker fill" type="color" value="#ff0000">
                            <button class="visibility-selection active">
                                <img class="selected-svg" th:src="@{/image/icons/view.svg}"/>
                                <img class="default-svg" th:src="@{/image/icons/hide.svg}"/>
                            </button>
                            <div>
                                <h5>#</h5>
                                <input class="colour-value" id="colourValueFill" value="FF0000">
                            </div>
                        </div>
                    </div>
                    <div class="outline-section">
                        <div class="header">
                            <h5>Outline</h5>
                        </div>
                        <div class="content">
                            <input class="colour-picker outline" type="color" value="#ff0000">
                            <button class="visibility-selection active">
                                <img class="selected-svg" th:src="@{/image/icons/view.svg}"/>
                                <img class="default-svg" th:src="@{/image/icons/hide.svg}"/>
                            </button>
                            <div>
                                <h5>#</h5>
                                <input class="colour-value" id="colourValueOutline" value="FF0000">
                            </div>
                        </div>
                    </div>
                </div>
                <button class="delete-button">
                    <span class="tooltip">Clear (C)</span>
                    <img class="default-svg" th:src="@{/image/icons/clear.svg}"/>
                </button>
                <div class="player-icon-container">
                    <div class="player-icon" ondragstart="return false;" ondrop="return false;"></div>
                    <div class="player-icon" ondragstart="return false;" ondrop="return false;"></div>
                    <button class="add-player-icon active">
                        <img th:src="@{/image/icons/add-white.svg}"/>
                    </button>
                </div>
                <button class="camera-button" id="camera-button">
                    <span class="tooltip">Camera (F)</span>
                    <img class="selected-svg" th:src="@{/image/icons/camera-active.svg}"/>
                    <img class="default-svg" th:src="@{/image/icons/camera.svg}"/>
                </button>
                <button class="recording-button">
                    <span class="tooltip">Record (R)</span>
                    <span class="recording-image"></span>
                    <span class="recording-image-border"></span>
                </button>
            </div>
            <div class="whiteboard">
                <div class="camera-flash" id="camera-flash"></div>
                <canvas id="canvas" width="560" height="700"></canvas>
            </div>
        </div>
    </div>
</div>

<!-- /* Upload Screenshot Modal */ -->
<!-- /* This is the darken effect that covers the entire screen */ -->
<div id="screenshot-modal" class="modal">
  <!-- /* This is the modal box */ -->
  <div class="modal-content">
    <button class="close-button" id="close-screenshot-modal">&times;</button>
    <h3 class="modal-header">Save Screenshot</h3>
    <!-- /* Displays the image about to be saved */ -->
    <img id="screenshot-display" class="screenshot-display" alt="Screenshot of the whiteboard" />
    <form id="screenshot-form" enctype="multipart/form-data" th:action="@{/whiteboard-media/save/screenshot}" method="post">
      <!-- /* We save the image in this invisible field */ -->
      <input type="file" id="screenshot-input" name="screenshot-input" />
      <input type="hidden" for="teamId" id="teamId" name="teamId" th:value="${teamId}"/>
  
      <div class="input-box">
        <input class="form-control" type="text" name="screenshot-name" id="screenshot-name" required>
        <label for="screenshot-name">
          Screenshot Name:
          <span class="required">*</span>
        </label>
      </div>

      <div class="input-box">
        <label for="isPublicCheckbox">Public:</label>
        <input type="checkbox" id="isPublicCheckbox" name="isPublicCheckbox" value="true">
      </div>

      <div class="submit-button">
        <button id="submit-screenshot" type="submit">Save</button>
      </div>
    </form>
  </div>
</div>

<video id="recorded-canvas" controls></video>

<script type="text/javascript" th:src="@{/webjars/fabric/5.3.0/dist/fabric.min.js}"></script>
<script type="text/javascript" th:src="@{/webjars/axios/1.4.0/dist/axios.min.js}"></script>
</body>
<script th:inline="javascript">

    /**
     * This handles the pitch dropdown selection for the whiteboard. There is a fixed list of pitchTypes and a for each loop is used to
     * create the option element for each pitch type.
     * When a pitchtype is selected then the image of the canvas is set to the pitch type's svg.
     */

    const pitchTypes = ["American Football", "Basketball", "Hockey", "Netball", "Rugby", "Soccer", "Tennis", "Volleyball"];
    const pitchSelect = document.getElementById("pitch");
    pitchTypes.forEach(pitchType => {
        const option = document.createElement("option");
        option.value = pitchType.toLowerCase().replace(" ", "-");
        option.textContent = pitchType;
        pitchSelect.appendChild(option);
    });



    /**
     * Handles editing the whiteboard name function. When the name is clicked, the name can be editable.
     * There is also a limit of 26 characters for the whiteboard name. When the limit of characters is reached, the name cannot be editable
     * unless clicked on again.
     */

    let isLabelFocused = false;
    const whiteboardDropdowns = document.querySelector('.whiteboard-dropdowns');
    const label = whiteboardDropdowns.querySelector('h3');

    label.addEventListener('click', () => {
        label.setAttribute('contenteditable', 'true');
        label.focus();
        isLabelFocused = true;
    });

    label.addEventListener('input', () => {
        const editedText = label.textContent;
        isLabelFocused = true;
        if (editedText.length >= 26) {
            label.textContent = editedText.slice(0, 26);
            label.setAttribute('contenteditable', 'false');
        } else {
            label.setAttribute('contenteditable', 'true');
        }
    });

    label.addEventListener('blur', () => {
        const editedText = label.textContent;
        label.textContent = editedText || 'Untitled';
        label.setAttribute('contenteditable', 'false');
        isLabelFocused = false;
    });

    /**
     * Functions related to the canvas
     */
    document.addEventListener("DOMContentLoaded", function () {
        let allowKeyPresses = true;

        pitchSelect.value = "soccer";
        let canvas = new fabric.Canvas('canvas');
        let activeMode = null;
        const imagePath = "image/pitches/";

        canvas.freeDrawingBrush.width = 5;
        canvas.freeDrawingBrush.color = '#ff0000';


        const defaultImageUrl = `${imagePath}${pitchSelect.value}.svg`;
        fabric.Image.fromURL(defaultImageUrl, function (img) {
            canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
        });


        pitchSelect.addEventListener("change", function () {
            const selectedValue = this.value;
            const imageUrl = `${imagePath}${selectedValue}.svg`;
            canvas.clear();

            fabric.Image.fromURL(imageUrl, function (img) {
                canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
            });

        });

        const playerCards = document.querySelectorAll('.player-card');
        const whiteboard = document.querySelector('.whiteboard');
        const playerUl = document.querySelector('.player-ul');
        const playerArray = [];
        const yPlayerOffset = 10;
        const xPlayerOffset = 20;



        /**
         * Handles the drag and drop of team players by adding mouse event listeners
         * to the team player-card element that is selected in the table. When the player-card is dropped on the whiteboard,
         * it is converted to fabric js component.
         */
        playerCards.forEach((playerCard, index) => {
            let isDragging;
            let initialCardX, initialCardY;

            playerCard.addEventListener("mousedown", (e) => {
                handleButtonClick("select-button", false, true);

                if (!playerCard.classList.contains('active')) {
                    playerCard.classList.add("active");
                }

                isDragging = true;
                playerCard.style.position = "absolute";

                initialCardX = playerCard.getBoundingClientRect().left;
                initialCardY = playerCard.getBoundingClientRect().top;


                playerCard.style.cursor = 'grabbing';
                playerCard.style.zIndex = '1';

                const newX = e.clientX - xPlayerOffset;
                const newY = e.clientY - yPlayerOffset;
                playerCard.style.left = `${newX}px`;
                playerCard.style.top = `${newY}px`;
            });

            document.addEventListener("mousemove", (e) => {
                if (isDragging) {
                    const newX = e.clientX - xPlayerOffset;
                    const newY = e.clientY - yPlayerOffset;

                    playerCard.style.left = `${newX}px`;
                    playerCard.style.top = `${newY}px`;
                }
            });

            document.addEventListener("mouseup", (e) => {
                if (isDragging) {
                    isDragging = false;

                    playerCard.style.cursor = 'grab';
                    playerCard.style.zIndex = '';

                    const whiteboardRect = whiteboard.getBoundingClientRect();
                    const cardRect = playerCard.getBoundingClientRect();

                    if (
                        cardRect.left >= whiteboardRect.left &&
                        cardRect.right <= whiteboardRect.right &&
                        cardRect.top >= whiteboardRect.top &&
                        cardRect.bottom <= whiteboardRect.bottom
                    ) {
                        playerArray.push({index: index, node: playerCard});

                        const canvasX = cardRect.left - canvas.upperCanvasEl.getBoundingClientRect().left;
                        const canvasY = cardRect.top - canvas.upperCanvasEl.getBoundingClientRect().top;
                        createTeamPlayerIcon(playerCard, canvasX, canvasY, index);

                        playerCard.style.display = 'none';
                    } else {
                        playerCard.style.position = "static";
                        playerCard.classList.remove("active");
                        playerUl.insertBefore(playerCard, playerUl.children[index]);
                    }
                }
            });
        });

        function getPlayerNameWidth(playerCard){
            const tempElement = document.createElement('span');
            tempElement.textContent = playerCard.querySelector('.player-name').textContent;
            tempElement.style.position = 'absolute';
            tempElement.style.left = '-9999px';
            document.body.appendChild(tempElement);
            const textContentWidth = tempElement.offsetWidth;
            document.body.removeChild(tempElement);
            return textContentWidth

        }

        var deleteIcon = "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E%3Csvg version='1.1' id='Ebene_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='595.275px' height='595.275px' viewBox='200 215 230 470' xml:space='preserve'%3E%3Ccircle style='fill:%23F44336;' cx='299.76' cy='439.067' r='218.516'/%3E%3Cg%3E%3Crect x='267.162' y='307.978' transform='matrix(0.7071 -0.7071 0.7071 0.7071 -222.6202 340.6915)' style='fill:white;' width='65.545' height='262.18'/%3E%3Crect x='266.988' y='308.153' transform='matrix(0.7071 0.7071 -0.7071 0.7071 398.3889 -83.3116)' style='fill:white;' width='65.544' height='262.179'/%3E%3C/g%3E%3C/svg%3E";
        var deleteImg = document.createElement('img');

        deleteImg.src= deleteIcon;
        /**
         * Takes the playerCard node, index of the node in the player list,
         * and canvas X and Y coordinates to place a fabric js player icon on the canvas.
         * @param {Element} playerCard playerCard <li> element that has been dropped on the canvas
         * @param {number} canvasX X coordinate of the mouse
         * @param {number} canvasY Y coordinates of the mouse
         * @param {number} index The index in the player list
         */
        function createTeamPlayerIcon(playerCard, canvasX, canvasY, index) {
            const playerNameWidth= getPlayerNameWidth(playerCard);
            const whiteCircle = new fabric.Circle({
                left: canvasX-15,
                top: canvasY,
                radius: 15,
                fill: 'white',
            });


            const playerCardSpan = playerCard.querySelector('.player-name').textContent;
            const playerCardImage= playerCard.querySelector('.player-image').src
            const playerName = new fabric.Text(playerCardSpan, {
                fill: 'black',
                left: canvasX - playerNameWidth/2,
                top: canvasY + 31,
                fontFamily: '"Noto Sans", sans-serif',
                fontSize: 16,
                fontWeight: 500,
            });

            fabric.Image.fromURL(playerCardImage, function (img) {

                img.set({
                    left: canvasX-15,
                    top: canvasY,
                    scaleX: 30 / img.width,
                    scaleY: 30 / img.height,
                    clipPath: new fabric.Ellipse({
                        rx: img.width/2,
                        ry: img.height/2,
                        originX: 'center',
                        originY: 'center',
                        fill: 'transparent',
                    }),
                });

                const group = new fabric.Group([whiteCircle, img, playerName], {
                    id: `teamPlayer:${index}`,
                    left: canvasX-xPlayerOffset-2,
                    top: canvasY-yPlayerOffset+10,
                });
                canvas.add(group);
                canvas.renderAll();
            });
        }

        function renderIcon(icon) {
            return function renderIcon(ctx, left, top, styleOverride, fabricObject) {
                let size = this.cornerSize;
                ctx.save();
                ctx.translate(left, top);
                ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle));
                ctx.drawImage(icon, -size/2, -size/2, size, size);
                ctx.restore();
            }
        }


        fabric.Object.prototype.controls.deleteControl = new fabric.Control({
            x: 0.5,
            y: -0.5,
            offsetY: -10,
            offsetX: 10,
            cursorStyle: 'pointer',
            mouseUpHandler: deleteObject,
            render: renderIcon(deleteImg),
            cornerSize: 24
        });

        function deleteObject(eventData, transform) {
            var target = transform.target;
            var _canvas = target.canvas;
            _canvas.remove(target);
            if (target.id.includes("teamPlayer")) {
                const number = target.id.match(/\d+/);
                const index = parseInt(number[0], 10);
                addTeamPlayer(index);
            }
            _canvas.requestRenderAll();
        }

        const upperCanvas = document.querySelector(".upper-canvas")

        /**
         * Handles the switching of whiteboard buttons and opening closing of dropdowns
         *
         * @param buttonClass button type e.g. shape, draw, erase etc.
         * @param drawMode boolean for whether the whiteboard is in drawing mode
         * @param selectMode boolean for whether the whiteboard is in selection mode
         */
        function handleButtonClick(buttonClass, drawMode, selectMode) {
            const buttons = document.querySelectorAll('.whiteboard-buttons button');
            buttons.forEach(button => {
                if (!button.parentElement.classList.contains("content") && !button.classList.contains("add-player-icon")
                    && !button.classList.contains("recording-button")) {
                    button.classList.remove('active')
                }
            });
            document.querySelector('.' + buttonClass).classList.add('active');

            const customisationBoxes = document.querySelectorAll('.customisation-box');
            customisationBoxes.forEach(box => {
                if (box.classList.contains(buttonClass.split('-')[0])) {
                    box.classList.toggle("active")
                } else {
                    box.classList.remove("active")
                }
            })

            activeMode = buttonClass;
            canvas.isDrawingMode = drawMode;
            canvas.selection = selectMode;
            upperCanvas.classList.remove("erase");
        }

        /**
         * Allows for dropdowns to close whenever they are clicked off
         */
        document.addEventListener('mousedown', function (event) {
            const buttonBox = document.querySelector(".whiteboard-buttons")
            // Check if the clicked element is not the box
            if (!buttonBox.contains(event.target)) {
                const customisationBoxes = document.querySelectorAll('.customisation-box');
                customisationBoxes.forEach(box => box.classList.remove('active'));
            }
        });

        document.querySelector('.draw-button').addEventListener('click', function () {
            handleButtonClick('draw-button', true, false);
        });

        document.querySelector('.erase-button').addEventListener('click', function () {
            handleButtonClick('erase-button', false, false);
            upperCanvas.classList.add("erase");
        });

        document.querySelector('.shape-button').addEventListener('click', function () {
            handleButtonClick('shape-button', false, false);
        });

        document.querySelector('.select-button').addEventListener('click', function () {
            handleButtonClick('select-button', false, true);
        });

        /* !! Screenshot code !! */
        const cameraButton = document.getElementById('camera-button');
        const cameraFlash = document.querySelector('#camera-flash');
        const screenshotModal = document.getElementById("screenshot-modal");
        const closeScreenshotModalButton = document.getElementById("close-screenshot-modal");
        const screenshotDisplay = document.getElementById('screenshot-display')
        const screenshotUpload = document.getElementById("screenshot-input");

        const mySound = new Audio("audio/cameraflash-cropped.mp3");
        mySound.preload = "auto";

        function createScreenshotModal() {
            // Disable keyboard shortcuts while typing
            allowKeyPresses = false;
            // Display the pitch inside the modal
            const dataURL = canvas.toDataURL();
            screenshotDisplay.src = dataURL;
            // Saves the image inside the modal's form
            fetch(dataURL)
                .then(res => res.blob())    // Base64 dataURL to binary
                .then(blob => {
                    // JavaScript's file APIs are very new and very bad
                    // Turn the binary into a file
                    const file = new File([blob], 'screenshot.png',
                        {type: "image/png"}
                    );
                    // Add the file to the form's hidden "file" input.
                    const dt = new DataTransfer();
                    dt.items.add(file);
                    screenshotUpload.files = dt.files;
            })

            screenshotModal.classList.add("modal-fade-in");
        }
        
        function closeScreenshotModal() {
            // Give keyboard shortcut controls back
            allowKeyPresses = true;
            screenshotModal.classList.remove("modal-fade-in");
        }

        /** Animates a camera flash on the whiteboard */
        function screenFlash() {
            cameraButton.classList.add('active');
            cameraFlash.classList.add("active");
            setTimeout(() => {
                cameraFlash.classList.remove("active");
            }, 990);
            mySound.play()
        }

        function clickCamera() {
            screenFlash();

            createScreenshotModal()
        }

        function deactivateCamera() {
            cameraButton.classList.remove('active');
        }

        cameraButton.addEventListener('click', clickCamera);
        cameraButton.addEventListener('mouseup', deactivateCamera);
        cameraButton.addEventListener('mouseleave', deactivateCamera);
        closeScreenshotModalButton.addEventListener('click', closeScreenshotModal);
        // Close the modal if you click outside the modal's content
        screenshotModal.addEventListener('click', (event) => {
            if (event.target == screenshotModal) {
                closeScreenshotModal();
            }
        });
        // Close the modal if you hit "Escape"
        document.addEventListener("keydown", (event) => {
            if (event.key === "Escape")
                closeScreenshotModal();
        });

        /* Recording code*/
        const recordingButton = document.querySelector('.recording-button');

        //This is used to display the recording on screen once recorded, for testing purposes
        const testVideoDisplay = document.getElementById('recorded-canvas');
        var whiteboardToRecord = document.querySelector("canvas");

        let recording = false;
        var videoStream = whiteboardToRecord.captureStream(30);
        var mediaRecorder = new MediaRecorder(videoStream);


        recordingButton.addEventListener('click', function () {
            toggleRecording();
            if (!recording) {
                var chunks = [];
                mediaRecorder.ondataavailable = function(e) {
                    chunks.push(e.data);
                };

                mediaRecorder.onstop = function(e) {
                    var blob = new Blob(chunks, { 'type' : 'video/mp4' });
                    chunks = [];
                    var videoURL = URL.createObjectURL(blob);
                    testVideoDisplay.src = videoURL;
                };
                mediaRecorder.ondataavailable = function(e) {
                    chunks.push(e.data);
                };

                mediaRecorder.start();
                recording = true;
            } else {
                mediaRecorder.stop();
                recording = false;
            }
        });

        function toggleRecording() {
            recordingButton.classList.toggle('active');
        }

        const formationDropdown = document.getElementById("formation-dropdown");
        const lineupDropdown = document.getElementById("lineup-dropdown");

        document.querySelector('.delete-button').addEventListener('click', function () {
            canvas.clear();
            formationDropdown.selectedIndex = 0;
            lineupDropdown.selectedIndex = 0;
            if (playerArray.length !== 0) {
                addTeamPlayers();
            }
        });

        /**
         * Handles switching line types for the free draw tool
         */
        const drawStyleButtonSolid = document.querySelector('.customisation-box.draw .draw-style-button-solid');
        const drawStyleButtonDashed = document.querySelector('.customisation-box.draw .draw-style-button-dashed');

        drawStyleButtonSolid.addEventListener('click', function () {
            switchLineTypes()
        });

        drawStyleButtonDashed.addEventListener('click', function () {
            switchLineTypes()
        });

        function switchLineTypes() {
            drawStyleButtonSolid.classList.toggle('active')
            drawStyleButtonDashed.classList.toggle('active')
            updateLineType()
        }


        function updateLineType() {
            const canvasWidth = 5 * canvas.freeDrawingBrush.width
            if (drawStyleButtonDashed.classList.contains('active')) {
                canvas.freeDrawingBrush.lineDashOffset = 0;
                canvas.freeDrawingBrush.strokeDashArray = [canvasWidth, canvasWidth / 2];
            } else {
                canvas.freeDrawingBrush.lineDashOffset = 0;
                canvas.freeDrawingBrush.strokeDashArray = [];
            }
        }

        /**
         * Handles switching line width for the free draw tool
         */
        const rangeInput = document.getElementById('rangeInput');
        const widthValueInput = document.getElementById('widthValue');

        rangeInput.addEventListener('input', function () {
            widthValueInput.value = this.value;
            canvas.freeDrawingBrush.width = parseInt(this.value, 10);
            updateLineType()

        });

        widthValueInput.addEventListener('input', function () {
            const newValue = this.value;
            if (newValue >= 1 && newValue <= 50) {
                rangeInput.value = newValue;
                canvas.freeDrawingBrush.width = parseInt(this.value, 10);
                updateLineType()
            }
        });

        /**
         * Handles switching colours for the free draw tool
         */
        const colourPicker = document.querySelector('.colour-picker');
        const colourValueInput = document.getElementById('colourValue');

        colourPicker.addEventListener('input', function () {
            const newColour = this.value;
            colourValueInput.value = newColour.substr(1).toUpperCase();
            canvas.freeDrawingBrush.color = this.value;
        });

        colourValueInput.addEventListener('input', function () {
            const newColour = this.value;
            if (isValidHexcolour(newColour)) {
                colourPicker.value = '#' + newColour;
                canvas.freeDrawingBrush.color = '#' + newColour;
            }
        });

        colourValueInput.addEventListener('keydown', function (event) {
            event.stopPropagation();
        });

        function isValidHexcolour(hex) {
            return /^([0-9A-F]{3}){1,2}$/i.test(hex);
        }

        /**
         * Handles shortcut functionality
         */
        document.addEventListener('keydown', function (event) {
            // If the whiteboard's not in focus (e.g. a modal's up), ignore keys
            if (!allowKeyPresses) return;

            if (event.key === 's') {
                handleButtonClick('select-button', false, true);
            } else if (event.key === 'd') {
                handleButtonClick('draw-button', true, false);
            } else if (event.key === 'e') {
                handleButtonClick('erase-button', false, false);
                upperCanvas.classList.add("erase");
            } else if (event.key === 'x') {
                handleButtonClick('shape-button', false, false);
            } else if (event.key === 'Delete' || event.key === 'Backspace') {
                const activeObject = canvas.getActiveObject()
                if (activeObject instanceof fabric.Group) {
                    if (activeObject.id && activeObject.id.includes("teamPlayer")) {
                        const number = activeObject.id.match(/\d+/);
                        const index = parseInt(number[0], 10);
                        addTeamPlayer(index);
                    }

                    activeObject.getObjects().forEach(obj => {
                        if (obj instanceof fabric.Group) {
                            obj.getObjects().forEach(child => {
                                canvas.remove(child);
                            })
                        }
                        canvas.remove(obj);
                    });
                }
                canvas.remove(...canvas.getActiveObjects());
                canvas.remove(canvas.getActiveObject())
                canvas.renderAll();
            } else if (event.key === 'c') {
                canvas.clear();
                if (playerArray.length !== 0) {
                    addTeamPlayers();
                }
                formationDropdown.selectedIndex = 0;
                lineupDropdown.selectedIndex = 0;
            } else if (event.key === 'f') {
                clickCamera();
            } else if (event.key === 'r') {
                toggleRecording();
            }
        });

        /**
         * Handles erasing objects with the eraser cursor
         */
        function eraseObjects(event) {
            let pointer = canvas.getPointer(event);
            let objects = canvas.getObjects();

            for (let i = 0; i < objects.length; i++) {
                if (objects[i].containsPoint(pointer)) {
                    if (objects[i] instanceof fabric.Group) {
                        if (objects[i].id && objects[i].id.includes("teamPlayer")) {
                            const number = objects[i].id.match(/\d+/);
                            const index = parseInt(number[0], 10);
                            addTeamPlayer(index);
                        }

                        objects[i].getObjects().forEach(obj => {
                            canvas.remove(obj);
                        });
                    }
                    canvas.remove(objects[i]);
                }
            }
            canvas.renderAll();
        }


        /**
         * Add all players from the player array back into the player table
         */
        function addTeamPlayers() {
            playerArray.forEach(({index, node}) => {
                insertPlayerInTable(index,node)
            })
        }

        /**
         * Retrieve the player element from the player array using the index
         * @param {number} index The index of the team player in the player list
         */
        function addTeamPlayer(index) {
            const teamPlayer = playerArray.find(item => item.index === index);
            insertPlayerInTable(index,teamPlayer.node);
        }
        /**
         * Adds the team player element back into the player table in the order of the index.
         * @param {number} index The index of the team player in the player list
         * @param {Element} node The index of the team player in the player list
         */
        function insertPlayerInTable(index, node){
            const playerList = document.querySelector('.player-ul');
            node.style.display = '';
            node.classList.remove("active");
            node.style.position = "static";
            if (index === 0) {
                if (playerList.firstChild) {
                    playerList.insertBefore(node, playerList.firstChild);
                } else {
                    playerList.appendChild(node);
                }
            } else {
                playerList.insertBefore(node, playerList.children[index - 1].nextSibling);
            }
        }


        /** Shapes **/

        /**
         * Handles switching border style for the shapes
         */
        let shapeOutline = [];

        const shapeStyleButtonSolid = document.querySelector('.customisation-box.shape .draw-style-button-solid');
        const shapeStyleButtonDashed = document.querySelector('.customisation-box.shape .draw-style-button-dashed');

        shapeStyleButtonSolid.addEventListener('click', function () {
            switchLineTypesShape()
        });

        shapeStyleButtonDashed.addEventListener('click', function () {
            switchLineTypesShape()
        });

        function switchLineTypesShape() {
            shapeStyleButtonSolid.classList.toggle('active')
            shapeStyleButtonDashed.classList.toggle('active')
            if (shapeStyleButtonDashed.classList.contains('active')) {
                shapeOutline = [10, 5];
            } else {
                shapeOutline = [];
            }
        }

        /**
         * Handles selecting the shape
         */
        let shape = 'circle'

        document.querySelector('.shape-button-circle').addEventListener('click', function () {
            handleShapeButtonClick('circle');
        });

        document.querySelector('.shape-button-ellipse').addEventListener('click', function () {
            handleShapeButtonClick('ellipse');
        });

        document.querySelector('.shape-button-triangle').addEventListener('click', function () {
            handleShapeButtonClick('triangle');
        });

        document.querySelector('.shape-button-square').addEventListener('click', function () {
            handleShapeButtonClick('square');
        });

        document.querySelector('.shape-button-rectangle').addEventListener('click', function () {
            handleShapeButtonClick('rectangle');
        });

        document.querySelector('.shape-button-line').addEventListener('click', function () {
            handleShapeButtonClick('line');
        });

        document.querySelector('.shape-button-arrow').addEventListener('click', function () {
            handleShapeButtonClick('arrow');
        });

        const shapeButton = document.querySelector('.shape-button');

        function handleShapeButtonClick(selectedShape) {
            const buttons = document.querySelectorAll('.shape-section button');
            buttons.forEach(button => button.classList.remove('active'));
            document.querySelector('.shape-button-' + selectedShape).classList.add('active');
            const classesToKeep = ['shape-button', 'active'];
            for (let i = shapeButton.classList.length - 1; i >= 0; i--) {
                const className = shapeButton.classList.item(i);
                if (!classesToKeep.includes(className)) {
                    shapeButton.classList.remove(className);
                }
            }
            shapeButton.classList.add(selectedShape)
            shape = selectedShape
        }

        /**
         * Handles selecting colour fill for the shape
         */
        let innerColour = '#FF0000'
        let innerHidden = false;

        const colourPickerFill = document.querySelector('.colour-picker.fill');
        const colourValueInputFill = document.getElementById('colourValueFill');

        colourPickerFill.addEventListener('input', function () {
            const newColour = this.value;
            colourValueInputFill.value = newColour.substr(1).toUpperCase();
            innerColour = this.value
            visibilitySelectionFill.classList.add('active')
            innerHidden = false;
        });

        colourValueInputFill.addEventListener('input', function () {
            const newColour = this.value;
            if (isValidHexcolour(newColour)) {
                colourPickerFill.value = '#' + newColour;
                innerColour = '#' + newColour;
                visibilitySelectionFill.classList.add('active')
                innerHidden = false;
            }
        });

        colourValueInputFill.addEventListener('keydown', function (event) {
            event.stopPropagation();
        });

        const visibilitySelectionFill = document.querySelector('.fill-section .visibility-selection');

        visibilitySelectionFill.addEventListener('click', function () {
            visibilitySelectionFill.classList.toggle('active')
            innerHidden = !innerHidden;
        });


        /**
         * Handles switching outline colour for the shape
         */
        let outerColour = '#FF0000'
        let outerHidden = false;

        const colourPickerOutline = document.querySelector('.colour-picker.outline');
        const colourValueInputOutline = document.getElementById('colourValueOutline');

        colourPickerOutline.addEventListener('input', function () {
            const newColour = this.value;
            colourValueInputOutline.value = newColour.substr(1).toUpperCase();
            outerColour = this.value
            visibilitySelectionOutline.classList.add('active')
            outerHidden = false;
        });

        colourValueInputOutline.addEventListener('input', function () {
            const newColour = this.value;
            if (isValidHexcolour(newColour)) {
                colourPickerOutline.value = '#' + newColour;
                outerColour = '#' + newColour;
                visibilitySelectionOutline.classList.add('active')
                outerHidden = false;
            }
        });

        const whiteboardTitle = document.querySelector(".whiteboard-title")

        colourValueInputOutline.addEventListener('keydown', function (event) {
            event.stopPropagation();
        });

        whiteboardTitle.addEventListener('keydown', function (event) {
            event.stopPropagation();
        });

        const visibilitySelectionOutline = document.querySelector('.outline-section .visibility-selection');

        visibilitySelectionOutline.addEventListener('click', function () {
            visibilitySelectionOutline.classList.toggle('active')
            outerHidden = !outerHidden;
        });


        /**
         * Functionality for drawing shapes
         */

        let mouseDown = false;
        let drawingShape = null;
        let startX;
        let startY;
        let maxWidth;
        let maxHeight;
        let leftLine;
        let rightLine;
        const aw = 36;

        /**
         * Handles mouse:down interaction. Encompasses creating the shapes, and setting their origin. Also includes
         * call for erase tool.
         */
        canvas.on('mouse:down', function (options) {
            const {x, y} = canvas.getPointer(options.e);
            if (canvas.getActiveObject() && activeMode !== "erase-button") {
                handleButtonClick('select-button', false, true);
            }
            startX = x
            startY = y
            maxWidth = canvas.width - x;
            maxHeight = canvas.height - y;
            if (options.e.button === 0) {
                mouseDown = true;
                if (activeMode === 'erase-button') {
                    eraseObjects(options.e);
                } else if (activeMode === 'shape-button') {
                    if (shapeButton.classList.contains("circle")) {
                        drawingShape = new fabric.Circle({
                            left: options.e.clientX - canvas._offset.left,
                            top: options.e.clientY - canvas._offset.top,
                            radius: 0,
                            fill: !innerHidden ? innerColour : null,
                            stroke: !outerHidden ? outerColour : null,
                            strokeWidth: 5,
                            originX: 'center',
                            originY: 'center',
                            strokeDashArray: shapeOutline
                        });
                    } else if (shapeButton.classList.contains("ellipse")) {
                        // IDK why it's 3 pixels off but it is
                        maxWidth = maxWidth / 2 - 3
                        maxHeight = maxHeight / 2 - 3
                        drawingShape = new fabric.Ellipse({
                            left: startX,
                            top: startY,
                            rx: 0,
                            ry: 0,
                            fill: !innerHidden ? innerColour : 'transparent',
                            stroke: !outerHidden ? outerColour : 'transparent',
                            strokeWidth: 5,
                            strokeDashArray: shapeOutline
                        });
                    } else if (shapeButton.classList.contains("triangle")) {
                        drawingShape = new fabric.Triangle({
                            left: startX,
                            top: startY,
                            width: 0,
                            height: 0,
                            fill: !innerHidden ? innerColour : 'transparent',
                            stroke: !outerHidden ? outerColour : 'transparent',
                            strokeWidth: 5,
                            strokeDashArray: shapeOutline
                        });
                    } else if (shapeButton.classList.contains("square")) {
                        drawingShape = new fabric.Rect({
                            left: startX,
                            top: startY,
                            width: 0,
                            height: 0,
                            fill: !innerHidden ? innerColour : 'transparent',
                            stroke: !outerHidden ? outerColour : 'transparent',
                            strokeWidth: 5,
                            strokeDashArray: shapeOutline
                        });
                    } else if (shapeButton.classList.contains("rectangle")) {
                        drawingShape = new fabric.Rect({
                            left: startX,
                            top: startY,
                            width: 0,
                            height: 0,
                            fill: !innerHidden ? innerColour : 'transparent',
                            stroke: !outerHidden ? outerColour : 'transparent',
                            strokeWidth: 5,
                            strokeDashArray: shapeOutline
                        });
                    } else if (shapeButton.classList.contains("line")) {
                        drawingShape = new fabric.Line([startX, startY, startX, startY], {
                            left: startX,
                            top: startY,
                            fill: !innerHidden ? innerColour : 'transparent',
                            stroke: !outerHidden ? outerColour : 'transparent',
                            strokeWidth: 5,
                            strokeDashArray: shapeOutline
                        });
                    } else if (shapeButton.classList.contains("arrow")) {
                        drawingShape = new fabric.Line([startX, startY, startX, startY], {
                            left: startX,
                            top: startY,
                            fill: !innerHidden ? innerColour : null,
                            stroke: !outerHidden ? outerColour : null,
                            strokeWidth: 6,
                            strokeDashArray: shapeOutline,
                            evented: false,
                            selectable: false
                        });
                        leftLine = new fabric.Line([startX, startY, startX, startY], {
                            left: startX,
                            top: startY,
                            fill: !innerHidden ? innerColour : null,
                            stroke: !outerHidden ? outerColour : null,
                            strokeWidth: 6,
                            strokeDashArray: shapeOutline,
                            evented: false,
                            selectable: false
                        });
                        rightLine = new fabric.Line([startX, startY, startX, startY], {
                            left: startX,
                            top: startY,
                            fill: !innerHidden ? innerColour : null,
                            stroke: !outerHidden ? outerColour : null,
                            strokeWidth: 6,
                            strokeDashArray: shapeOutline,
                            evented: false,
                            selectable: false
                        });
                        canvas.add(leftLine);
                        canvas.add(rightLine);
                    }
                    canvas.add(drawingShape);
                }
            }
        });

        /**
         * Handles mouse:move interaction. While mouse:down draws the shapes.
         */
        canvas.on('mouse:move', function (options) {
            const pointer = canvas.getPointer(options.e);
            const {x, y} = pointer;
            if (mouseDown) {
                if (activeMode === "erase-button") {
                    eraseObjects(options.e);
                } else if (activeMode === "shape-button") {
                    if (shapeButton.classList.contains("circle")) {
                        const dx = x - drawingShape.left;
                        const dy = y - drawingShape.top;
                        const newRadius = Math.sqrt(dx * dx + dy * dy);
                        drawingShape.set({radius: newRadius});
                        canvas.renderAll();
                    } else if (shapeButton.classList.contains("square")) {
                        const width = Math.max(Math.abs(startX - x), Math.abs(startY - y)) * 2
                        const height = Math.max(Math.abs(startX - x), Math.abs(startY - y)) * 2
                        drawingShape.set({
                            width: width,
                            height: height,
                            left: startX - (width / 2),
                            top: startY - (height / 2)
                        });
                        canvas.renderAll();
                    } else if (shapeButton.classList.contains("rectangle") || shapeButton.classList.contains("triangle")) {
                        if (startX > x) {
                            if (x < 0) {
                                drawingShape.set({left: 0});
                            } else {
                                drawingShape.set({left: Math.abs(x)});
                            }
                            drawingShape.set({width: Math.abs(startX - Math.max(x, 0))});
                        } else {
                            drawingShape.set({width: Math.min(maxWidth, Math.abs(startX - Math.max(x, 0)))});
                        }
                        if (startY > y) {
                            if (y < 0) {
                                drawingShape.set({top: 0});
                            } else {
                                drawingShape.set({top: Math.abs(y)});
                            }
                            drawingShape.set({height: Math.abs(startY - Math.max(y, 0))});
                        } else {
                            drawingShape.set({height: Math.min(maxHeight, Math.abs(startY - Math.max(y, 0)))});
                        }
                        canvas.renderAll();
                    } else if (shapeButton.classList.contains("ellipse")) {
                        if (startX > x) {
                            if (x < 0) {
                                drawingShape.set({left: 0});
                            } else {
                                drawingShape.set({left: Math.abs(x)});
                            }
                            drawingShape.set({rx: Math.abs(startX - Math.max(x, 0)) / 2});
                        } else {
                            drawingShape.set({rx: Math.min(maxWidth, Math.abs(startX - Math.max(x, 0)) / 2)});
                        }
                        if (startY > y) {
                            if (y < 0) {
                                drawingShape.set({top: 0});
                            } else {
                                drawingShape.set({top: Math.abs(y)});
                            }
                            drawingShape.set({ry: Math.abs(startY - Math.max(y, 0)) / 2});
                        } else {
                            drawingShape.set({ry: Math.min(maxHeight, Math.abs(startY - Math.max(y, 0)) / 2)});
                        }
                        canvas.renderAll();
                    } else if (shapeButton.classList.contains("line")) {
                        // Have to do to separately as the line glitches if you set x/y to the value it already is
                        if (x !== startX) {
                            drawingShape.set({x2: x})
                        }
                        if (y !== startY) {
                            drawingShape.set({y2: y})
                        }
                        canvas.renderAll();
                    } else if (shapeButton.classList.contains("arrow")) {
                        const y11 = drawingShape.get('y1');
                        const y12 = drawingShape.get('y2');
                        const x11 = drawingShape.get('x1');
                        const x12 = drawingShape.get('x2');
                        const angleRad = Math.atan2(y12 - y11, x12 - x11);
                        const xDis = x - startX;
                        const yDis = y - startY;
                        let h = Math.abs(y12 - y11);
                        let w = Math.abs(x12 - x11);
                        let xLeft;
                        let yLeft;
                        let xRight;
                        let yRight;
                        const angle = Math.PI / 4
                        if (xDis <= 0 && yDis <= 0) {
                            xLeft = -(aw * Math.sin(Math.atan(h / w) - angle));
                            yLeft = aw * Math.cos(Math.atan(h / w) - angle);
                            xRight = aw * Math.cos(Math.atan(h / w) - angle);
                            yRight = aw * Math.sin(Math.atan(h / w) - angle);
                        } else if (xDis > 0 && yDis <= 0) {
                            xLeft = aw * Math.sin(Math.atan(h / -w) - angle);
                            yLeft = -(aw * Math.cos(Math.atan(h / -w) - angle));
                            xRight = -(aw * Math.cos(Math.atan(h / -w) - angle));
                            yRight = -(aw * Math.sin(Math.atan(h / -w) - angle));
                        } else if (xDis >= 0 && yDis >= 0) {
                            xLeft = aw * Math.sin(Math.atan(h / w) - angle);
                            yLeft = -(aw * Math.cos(Math.atan(h / w) - angle));
                            xRight = -(aw * Math.cos(Math.atan(h / w) - angle));
                            yRight = -(aw * Math.sin(Math.atan(h / w) - angle));
                        } else if (xDis < 0 && yDis > 0) {
                            xLeft = -(aw * Math.sin(Math.atan(h / -w) - angle));
                            yLeft = aw * Math.cos(Math.atan(h / -w) - angle);
                            xRight = aw * Math.cos(Math.atan(h / -w) - angle);
                            yRight = aw * Math.sin(Math.atan(h / -w) - angle);
                        }
                        if (x !== startX) {
                            drawingShape.set({x2: x})
                        }
                        if (y !== startY) {
                            drawingShape.set({y2: y})
                        }
                        const xLeftDis = x - 1.5 * Math.sin(angleRad);
                        const yLeftDis = y + 1.5 * Math.cos(angleRad);
                        const xRightDis = x + 1.5 * Math.sin(angleRad);
                        const yRightDis = y - 1.5 * Math.cos(angleRad);
                        leftLine.set({x1: xLeftDis, y1: yLeftDis, x2: x + xLeft, y2: y + yLeft})
                        rightLine.set({x1: xRightDis, y1: yRightDis, x2: x + xRight, y2: y + yRight})
                        canvas.renderAll();
                    }
                }
            }
        });

        /**
         * Handles mouse:up interaction. Stops the drawing of shapes, and groups the arrow elements into a single shape.
         */
        canvas.on('mouse:up', function () {
            mouseDown = false;
            if (activeMode === "shape-button") {
                drawingShape.setCoords();
                if (shapeButton.classList.contains("arrow")) {
                    leftLine.setCoords();
                    rightLine.setCoords();
                    // Create a group to contain the lines
                    const lineGroup = new fabric.Group([], {
                        left: startX,
                        top: startY,
                        fill: !innerHidden ? innerColour : null,
                        stroke: !outerHidden ? outerColour : null,
                        strokeWidth: 6,
                        strokeDashArray: shapeOutline,
                    });

                    lineGroup.addWithUpdate(drawingShape);
                    lineGroup.addWithUpdate(leftLine);
                    lineGroup.addWithUpdate(rightLine);
                    // Old arrow elements get pushed to the top left corner for some reason so need to delete them
                    canvas.add(lineGroup);
                    lineGroup.setCoords();
                }
                canvas.renderAll();
            }
        });

        /**Lineup Loading**/
        document.getElementById("lineup-dropdown").addEventListener("change", function (event) {
            const selectedOption = event.target.options[event.target.selectedIndex];
            formationDropdown.selectedIndex = 0;
            loadLineUp(selectedOption);
        });

        function loadLineUp(target) {
            const lineUpId = target.value;
            const formation = target.textContent;
            const custom = target.getAttribute("data-custom")
            const customPlayerPositions = target.getAttribute("data-custom-positions");
            canvas.clear();
            if (playerArray.length !== 0) {
                addTeamPlayers();
            }
            if (parseInt(lineUpId) !== -1) {
                getLineUpPositions(formation, custom, customPlayerPositions, lineUpId)
            } else {
                canvas.clear();
            }
        }

        function getLineUpPositions(formation, custom, customPlayerPositions, lineUpId) {
            axios.get("whiteboard/get-lineup", { params: { lineUpId: lineUpId } })
                .then(response => {
                    formationSwitch(formation, custom, customPlayerPositions, response.data);
                })
                .catch(error => {
                    alert("ERROR see console");
                    console.error(error);
                });
        }

        /**
         * Takes the playerCard node, index of the node in the player list,
         * and canvas X and Y coordinates to place a fabric js player icon on the canvas.
         * @param {number} id playerId for getting img
         * @param {string} name player name
         * @param {number} canvasX X coordinate of the mouse
         * @param {number} canvasY Y coordinates of the mouse
         */
        function createLineupTeamPlayerIcon(id, name, canvasX, canvasY, index) {

            const imageURL = "user-profile-picture/" + id;

            const whiteCircle = new fabric.Circle({
                left: canvasX,
                top: canvasY,
                radius: 15,
                fill: 'white',
            });

            const playerName = new fabric.Text(name, {
                fill: 'black',
                left: canvasX - 23,
                top: canvasY + 31,
                fontFamily: '"Noto Sans", sans-serif',
                fontSize: 16,
                fontWeight: 500,
            });
            fabric.Image.fromURL(imageURL, function (img) {

                img.set({
                    left: canvasX,
                    top: canvasY,
                    scaleX: 30 / img.width,
                    scaleY: 30 / img.height,
                    clipPath: new fabric.Ellipse({
                        rx: img.width/2,
                        ry: img.height/2,
                        originX: 'center',
                        originY: 'center',
                        fill: 'transparent',
                    }),
                });

                const group = new fabric.Group([whiteCircle, img, playerName], {
                    id: `teamPlayer:${index}`,
                    left: canvasX-xPlayerOffset-2,
                    top: canvasY-yPlayerOffset+10,
                    hasControls: false,
                });
                canvas.add(group);
                canvas.renderAll();
            });
        }


        /** Formation **/
        document.getElementById("formation-dropdown").addEventListener("change", function (event) {

            const defaultImageUrl = `${imagePath}${pitchSelect.value}.svg`;
            fabric.Image.fromURL(defaultImageUrl, function (img) {
                canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
            });

            const selectedOption = event.target.options[event.target.selectedIndex];
            lineupDropdown.selectedIndex = 0;
            loadFormation(selectedOption);


        });

        /**
         * Calls correct function for formation generation based on whether the formation is custom after selection
         * from dropdown.
         *
         * @param target selected formation from dropdown
         */
        function loadFormation(target) {
            const formationId = target.value;
            const formation = target.textContent;
            const custom = target.getAttribute("data-custom")
            const customPlayerPositions = target.getAttribute("data-custom-positions");
            canvas.clear();
            if (playerArray.length !== 0) {
                addTeamPlayers();
            }
            if (parseInt(formationId) !== -1) {
                formationSwitch(formation, custom, customPlayerPositions, null);
            }
        }

        /**
         * Determines what to data to load to generate the formation
         *
         * @param formation formation string
         * @param custom boolean for whether formation is custom
         * @param customPlayerPositions custom player positions
         * @param lineUpId if the line-up is -1 then don't generate as line-up else generate as line up
         */
        function formationSwitch(formation, custom, customPlayerPositions, lineUpPositions) {
            if (custom === true || custom === "true") {
                renderPlayersCustom(customPlayerPositions, lineUpPositions)
            } else {
                renderPlayers(formation, lineUpPositions)
            }
        }

        const radius = 14;

        /**
         * Renders formation on the canvas from the provided string.
         *
         * @param formationString formation in string form, e.g. '1-4-4-2'
         * @param lineUpPositions players in each position
         */
        function renderPlayers(formationString, lineUpPositions) {
            const formation = formationString.split("-").map(num => parseInt(num));
            // Builds formation
            let j = 0;
            for (let i = 0; i < formation.length; i++) {
                let playersInRow = formation[i]
                while (formation[i] !== 0) {
                    const top = canvas.height - ((i + 1) / (formation.length + 1)) * canvas.height;
                    const left = ((playersInRow - formation[i] + 1) / (playersInRow + 1)) * canvas.width;
                    if (!lineUpPositions) {
                        createPlayerIcon(left, top, '#EA3B52')
                    } else {
                        handleLineupGeneration(lineUpPositions, j, left, top);
                    }

                    formation[i] -= 1;
                    j++;
                }
            }
        }

        /**
         * Renders formation on the canvas from provided lineup
         *
         * @param positions positions of the icons on the pitch, in form e.g.'20px,30px;40px,60px;'
         */
        function renderPlayersCustom(positions, lineUpPositions) {
            // Due to a lack of foresight the displacement is saved as a static px value rather than a percentage, hence
            // it is prudent to turn the value into a percentage
            const pitchHeightOriginal = 360;
            const pitchWidthOriginal = 288;

            const positionsList = positions.split(';')
            let numPlayers = positionsList.length;
            for (let i = 0; i < numPlayers; i++) {
                let coordinates = positionsList[i].split(",")
                const left = parseInt(coordinates[0]) * canvas.width / pitchWidthOriginal;
                let top = canvas.width - parseInt(coordinates[1]) * canvas.width / pitchHeightOriginal;
                if (!lineUpPositions) {
                    createPlayerIcon(left, top, '#EA3B52')
                } else {
                    handleLineupGeneration(lineUpPositions, i, left, top);
                }
            }
        }

        function handleLineupGeneration(lineUpPositions, i, left, top) {
            const lineUpPosition = lineUpPositions.lineUpPositions[i];
            const userInfo = lineUpPosition.userInfo
            const playerName = userInfo.firstName + " " + userInfo.lastName;
            const playerId = userInfo.userId;
            playerCards.forEach((playerCard, index) => {
                const id = playerCard.querySelector("input").value;
                if (parseInt(id) === playerId) {
                    console.log(id, playerId)
                    playerArray.push({index: index, node: playerCard});
                    playerCard.style.display = 'none';
                    createLineupTeamPlayerIcon(playerId, playerName, left, top, index);
                }
            })
        }


        /**
         * Sets the colour of the initial default player icons in the navbar
         */
        const playerIconsContainer = document.querySelector(".player-icon-container");
        let playerIcons = document.querySelectorAll(".player-icon");
        const playerAdd = document.querySelector(".add-player-icon");
        const colours = ['#ff762b', '#5dbb63', '#ffef05', '#EA3B52', '#415A77']
        for (let i = 0; i < playerIcons.length; i++) {
            const icon = playerIcons[i];
            icon.style.background = colours.pop();
            addPlayerIconMovement(icon);
        }

        /**
         * Handles adding additional default player icons
         */
        playerAdd.addEventListener('click', function () {
            playerIcons = document.querySelectorAll(".player-icon");
            if (playerIcons.length < 5) {
                const playerIcon = playerIcons[0].cloneNode(true);
                playerIcon.style.background = colours.pop();
                playerIconsContainer.insertBefore(playerIcon, playerAdd);
                if (playerIcons.length === 4) {
                    playerAdd.classList.remove("active")
                    playerIcon.style.marginRight = "3px";
                }
                addPlayerIconMovement(playerIcon);
            }
        });

        /**
         * Adds functionality for moving default player icons
         *
         * @param playerIcon default player icon html object
         */
        function addPlayerIconMovement(playerIcon) {
            let iconIsDragging = false;
            let drawingMode = false;
            const yOffset = 15;
            const xOffset = 18;
            let copyIcon;
            let newX;
            let newY;

            playerIcon.addEventListener("mousedown", (e) => {
                if (canvas.isDrawingMode) {
                    drawingMode = true;
                    canvas.isDrawingMode = false;
                    canvas.selection = true
                }
                iconIsDragging = true;
                copyIcon = playerIcon.cloneNode(false)
                copyIcon.classList.add("active")
                playerIconsContainer.appendChild(copyIcon);

                newX = e.clientX - xOffset;
                newY = e.clientY - yOffset;
                copyIcon.style.left = `${newX}px`;
                copyIcon.style.top = `${newY}px`;
            });

            document.addEventListener("mousemove", (e) => {
                if (iconIsDragging) {
                    newX = e.clientX - xOffset;
                    newY = e.clientY - yOffset;
                    copyIcon.style.left = `${newX}px`;
                    copyIcon.style.top = `${newY}px`;
                }
            })

            document.addEventListener("mouseup", (e) => {
                const whiteboardRect = canvas.upperCanvasEl.getBoundingClientRect()
                const pointer = canvas.getPointer(e);
                const {x, y} = pointer;
                if (iconIsDragging) {
                    if (x > -radius && y > -radius && x < canvas.width + radius && y < canvas.height + radius) {
                        const canvasLeft = whiteboardRect.left;
                        const canvasTop = whiteboardRect.top;
                        const xP = e.clientX - canvasLeft;
                        const yP = e.clientY - canvasTop;
                        createPlayerIcon(xP, yP, copyIcon.style.background)
                        if (drawingMode) {
                            drawingMode = false;
                            canvas.isDrawingMode = true;
                            canvas.selection = false;
                        }
                    }
                    iconIsDragging = false;
                    playerIconsContainer.removeChild(copyIcon)
                    copyIcon.remove();
                }
            })
        }

        /**
         * Generates a default player icon on the canvas
         */
        function createPlayerIcon(x, y, fill) {
            const playerIconOuter = new fabric.Circle({
                left: x,
                top: y,
                radius: radius,
                fill: "white",
                stroke: "black",
                strokeWidth: 2,
                originX: 'center',
                originY: 'center'
            });
            const playerIconInner = new fabric.Circle({
                left: x,
                top: y,
                radius: radius - 4,
                fill: fill,
                strokeWidth: 2,
                originX: 'center',
                originY: 'center'
            });
            const group = new fabric.Group([playerIconOuter, playerIconInner], {
                id: 'default',
                left: x,
                top: y,
                originX: 'center',
                originY: 'center',
                hasControls: false
            });
            canvas.add(group)
        }
    })

    // ability to send post req without refreshing 
    const form = document.getElementById('screenshot-form')
    form.addEventListener('submit', function(e) {
        e.preventDefault()
        const formData = new FormData(form)
        sendWhiteboardWithoutRefreshing(formData)
    })

    function sendWhiteboardWithoutRefreshing(formData) {
        axios.post("whiteboard-media/save/screenshot", formData)
            .then(response => {
                // open up in a new tab?
                closeScreenshotModalAfterPost()
            })
            .catch(error => {
                alert("ERROR see console");
                console.error(error);
            });
    }

    function closeScreenshotModalAfterPost() {
        screenshotModal = document.getElementById("screenshot-modal");
        allowKeyPresses = true;
        screenshotModal.classList.remove("modal-fade-in");
    }

    const isPublicCheckbox = document.getElementById("isPublicCheckbox");

    isPublicCheckbox.addEventListener("change", () => {
        document.querySelector('input[name="isPublic"]').value = isPublicCheckbox.checked ? "true" : "false";
    });



</script>
</html>
